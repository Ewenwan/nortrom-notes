
[toc]

[programming](./java.md)

* java virtual machine notes
    * ***BYTECODE***
    * The bytecodes are executed in an execution engine, which is one part of the virtual machine that can vary in different implementations. On a Java Virtual Machine implemented in software, **the simplest kind of execution engine just interprets the bytecodes one at a time**. Another kind of execution engine, one that is faster but requires more memory, is a **just-in-time compiler**. In this scheme, **the bytecodes of a method are compiled to native machine code the first time the method is invoked**. The native machine code for the method is then cached, so it can be re-used the next time that same method is invoked.
    * ***JAVA INTERPRETER***
    * Sometimes the Java Virtual Machine is called the Java interpreter; however, given the various ways in which bytecodes can be executed, this term can be misleading. While "Java interpreter" is a reasonable name for a Java Virtual Machine that interprets bytecodes, virtual machines also use other techniques (such as just-in-time compiling) to execute bytecodes. Therefore, **although all Java interpreters are Java Virtual Machines, not all Java Virtual Machines are Java interpreters**.
    * ***CLASS LOADER***
    * A Java application can use two types of class loaders: a **"primordial" class loader** and **class loader objects**. The primordial class loader (there is only one of them) is a part of the Java Virtual Machine implementation. For example, if a Java Virtual Machine is implemented as a C program on top of an existing operating system, then the primordial class loader will be part of that C program. **The primordial class loader loads trusted classes, including the classes of the Java API**, usually from the local disk. At run-time, a Java application can install class loader objects that load classes in custom ways, such as by downloading class files across a network. The Java Virtual Machine considers **any class it loads through the primordial class loader to be trusted**, regardless of whether or not the class is part of the Java API. Classes it loads through class loader objects, however, it views with suspicion--by default, it considers them to be untrusted. While the primordial class loader is an intrinsic part of the virtual machine implementation, class loader objects are not. Instead, **class loader objects are written in Java, compiled to class files, loaded into the virtual machine, and instantiated just like any other object**. They are really just another part of the executable code of a running Java application.
    * Because of class loader objects, you donít have to know at compile-time all the classes that may ultimately take part in a running Java application. They enable you to dynamically extend a Java application at run-time.
    * When a loaded class first refers to another class, the virtual machine requests the referenced class from the same class loader that originally loaded the referencing class.
    * Because the Java Virtual Machine takes this approach to loading classes, **classes can by default only see other classes that were loaded by the same class loader**. This is how Javaís architecture enables you to create multiple name-spaces inside a single Java application. A Java application can instantiate multiple class loader objects either from the same class or from multiple classes. It can, therefore, create as many (and as many different kinds of) class loader objects as it needs. Classes loaded by different class loaders are in different name-spaces and cannot gain access to each other unless the application explicitly allows it. When you write a Java application, you can segregate classes loaded from different sources into different name-spaces. In this way, you can use Javaís class loader architecture to control any interaction between code loaded from different sources. You can prevent hostile code from gaining access to and subverting friendly code.